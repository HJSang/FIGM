{
    "collab_server" : "",
    "contents" : "\n#include <RcppArmadillo.h>\n//[[Rcpp::depends(RcppArmadillo)]]\n\nusing namespace Rcpp;\nusing namespace arma;\n\n//[[Rcpp::export]]\narma::mat mvrnormArma(int n, arma::vec mu, arma::mat sigma) {\n  int ncols = sigma.n_cols;\n  arma::mat Y = arma::randn(n, ncols);\n  return arma::repmat(mu, 1, n).t() + Y * arma::chol(sigma);\n}\n\n\n//******************************************************\n// Fractional Imputation using Gaussion Model\n//********************************************************\n\n\n//From Original data to extract obs and mis\nvoid find_obs(mat & s,mat & obs, mat & mis)\n{\n  int n=s.n_rows;\n  for(int i=0; i<n;i++)\n  {\n    uvec a=find((s.row(i)).t()==0);\n    if(a.n_elem>0)\n      mis=join_cols(mis,s.row(i));\n    else\n      obs=join_cols(obs,s.row(i));\n  }\n}\n\n\n\n//Proposal disribution estimates\nvoid proposal_est(mat & obs, vec & mu0, mat & S0)\n{\n  mu0=(mean(obs,0)).t();\n  S0=cov(obs);\n}\n\n\n//Proposal Imputation\nvoid Imputation(mat & s,vec & mu0, mat & S0, mat & com , int m)\n{\n  int n=s.n_rows;\n  int i;\n  vec z;\n  uvec ind, ind1, ind2;\n  mat temp;\n  // add id variable\n  mat s1=join_rows(linspace(1,n,n),s);\n  for(i=0; i<n; i++)\n  {\n    z=(s1.row(i)).t();\n    ind=find(z==0);\n    if(ind.n_elem==0)\n      temp=(join_cols(z, ones(2))).t();\n    else\n    {\n      temp=repmat(z.t(),m,1);\n      temp=join_rows(temp, zeros(m,2));\n      temp.col(temp.n_cols-1)=1.0/m*ones(m);\n\n      // imputation\n      vec z1=z.subvec(1,z.n_elem-1);\n      vec mu1=mu0(find(z1==0));\n      vec mu2=mu0(find(z1!=0));\n      int r1=mu1.n_elem;\n      int r2=mu2.n_elem;\n      ind1=find(z1==0);\n      ind2=find(z1!=0);\n      mat S1(r1,r1), S2(r2,r2), S3(r1,r2);\n      for(int i=0; i<r1; i++)\n        for(int j=0; j<r1; j++)\n          S1(i,j)=S0(ind1(i),ind1(j));\n\n      for(int i=0; i<r2; i++)\n        for(int j=0; j<r2; j++)\n          S2(i,j)=S0(ind2(i),ind2(j));\n\n      for(int i=0; i<r1; i++)\n        for(int j=0; j<r2; j++)\n          S3(i,j)=S0(ind1(i),ind2(j));\n      vec b=z1(find(z1!=0));\n\n      vec mu_star=mu1+S3*S2.i()*(b-mu2);\n      mat S_star=S1-S3*S2.i()*S3.t();\n\n      mat y_star=mvrnormArma(m,mu_star,S_star);\n      for(int i=0; i<(int) ind.n_elem; i++)\n        temp.col(ind(i))=y_star.col(i);\n\n    }\n    com=join_cols(com,temp);\n\n  }\n\n}\n\n// parameter estimation\n\nvoid est1(mat & com, vec & mu, mat & S, vec & prob, vec & q)\n{\n  int p=com.n_cols-3;\n  vec w=com.col(com.n_cols-1);\n  mat d=com.submat(0,1,com.n_rows-1,p);\n  //cout<<\"p\\n\"<<p<<\"\\n\";\n  for(int i=0;i<p; i++)\n  {\n    mu(i)=sum(d.col(i)%w)/sum(w);\n    prob(i)=sum((d.col(i)<q(i))%w)/sum(w);\n  }\n  //cout<<\"mu\\n\"<<mu<<\"\\n\";\n\n  for(int i=0;i<p; i++)\n    for(int j=0; j<p; j++)\n    {\n      S(i,j)=sum((d.col(i)-mu(i))%(d.col(j)-mu(j))%w)/sum(w);\n    }\n // cout<<\"S\\n\"<<S<<\"\\n\";\n}\n\n\n\n//weights update\nvoid updatew(mat & com, vec & mu, mat & S, vec & mu0, mat & S0, int m)\n{\n  //int n=(com.col(0)).max();\n  int p=com.n_cols;\n  //cout<<\"com\\n\"<<com.n_rows<<\"\\n\";\n  int i=0;\n  while(i <(int) com.n_rows)\n  {\n    if(com(i,p-2)==1)\n    {\n      i=i+1;\n    }\n    else\n    {\n      mat Y=com.submat(i,1,i+m-1,p-3);\n      //cout<<\"Y\\n\"<<Y<<\"\\n\";\n      vec w(m);\n      for(int j=0; j<m; j++)\n      {\n        vec z=(Y.row(j)).t();\n        w(j)=exp(0.5*as_scalar((z-mu0).t()*S0.i()*(z-mu0)-(z-mu).t()*S.i()*(z-mu))+\n          0.5*log(det(S0))-0.5*log(det(S)));\n      }\n      w=w/sum(w);\n      //cout<<\"w\\n\"<<w<<\"\\n\";\n      com.submat(i,p-1,i+m-1,p-1)=w;\n      i=i+m;\n    }\n    //cout<<\"i\\n\"<<i<<\"\\n\";\n  }\n}\n\n\n//FI\n//[[Rcpp::export]]\nvec FIMV(mat s,vec q, int iter, int m)\n{\n  //int n=s.n_rows;\n  int p=s.n_cols;\n  int i;\n  mat obs, mis;\n  find_obs( s, obs,mis);\n  vec mu0;\n  mat S0;\n  proposal_est( obs, mu0,S0);\n  cout<<\"mu0\\t\"<<mu0<<\"\\n\";\n  mat com;\n  Imputation(s, mu0,S0,com ,m);\n  //cout<<\"com\\n\"<<com.head_rows(5)<<\"\\n\";\n  vec mu=mu0, prob=zeros(p);\n  mat S(p,p);\n  vec p1=mu0;\n\n  for(i=0; i<iter; i++)\n  {\n    est1(com, mu, S, prob,q);\n    cout<<\"i\\n\"<<i<<\"\\n\";\n    cout<<\"mu\\n\"<<mu<<\"\\n\";\n    updatew(com, mu, S, mu0, S0, m);\n    if(norm(mu-p1)/norm(mu)<1e-6) break;\n    p1=mu;\n  }\n\n  vec result=join_cols(mu, prob);\n  result=join_cols(result, vectorise(S));\n\n  return result;\n}\n\n\n\n\n\n//***********************************************\n// Using GMM method\n//************************************************\n\n\n//Imputatin for model and Missing data\nvoid ImputationGMM(mat & s, vec & mu0, mat & S0, int G, int m, mat & com)\n{\n  int n=s.n_rows;\n  //int p=s.n_cols;\n  mat s1=join_rows(linspace(1,n,n),s);\n  //cout<<\"s1\\n\"<<s1.head_rows(5)<<\"\\n\";\n  vec z;\n  uvec ind;\n  mat temp;\n  for(int i=0; i<n; i++)\n  {\n    z=(s1.row(i)).t();\n    //cout<<\"z\\n\"<<z<<\"\\n\";\n    ind=find(z==0);\n    if(ind.n_elem==0)\n    {\n      temp=repmat(z.t(),G,1);\n      temp=join_rows(temp,ones(G));\n      temp=join_rows(temp,linspace(1,G,G));\n      temp=join_rows(temp,1.0/G*ones(G));\n\n    }\n    else\n    {\n      temp=repmat(z.t(),G*m,1);\n     // cout<<\"temp\\n\"<<temp<<\"\\n\";\n      temp=join_rows(temp,zeros(G*m));\n     // cout<<\"temp\\n\"<<temp<<\"\\n\";\n      temp=join_rows(temp,kron(linspace(1,G,G),ones(m)));\n      //cout<<\"temp\\n\"<<temp<<\"\\n\";\n      temp=join_rows(temp,1.0/(G*m)*ones(G*m));\n      //cout<<\"temp\\n\"<<temp<<\"\\n\";\n      // Imputation\n      // imputation\n      vec z1=z.subvec(1,z.n_elem-1);\n      vec mu1=mu0(find(z1==0));\n      vec mu2=mu0(find(z1!=0));\n      int r1=mu1.n_elem;\n      int r2=mu2.n_elem;\n      uvec ind1=find(z1==0);\n      uvec ind2=find(z1!=0);\n      mat S1(r1,r1), S2(r2,r2), S3(r1,r2);\n      for(int i=0; i<r1; i++)\n        for(int j=0; j<r1; j++)\n          S1(i,j)=S0(ind1(i),ind1(j));\n\n      for(int i=0; i<r2; i++)\n        for(int j=0; j<r2; j++)\n          S2(i,j)=S0(ind2(i),ind2(j));\n\n      for(int i=0; i<r1; i++)\n        for(int j=0; j<r2; j++)\n          S3(i,j)=S0(ind1(i),ind2(j));\n      vec b=z1(find(z1!=0));\n\n      vec mu_star=mu1+S3*S2.i()*(b-mu2);\n      mat S_star=S1-S3*S2.i()*S3.t();\n\n      mat y_star=mvrnormArma(m*G,mu_star,S_star);\n      //cout<<\"y_star\\n\"<<y_star<<\"\\n\";\n      for(int i=0; i<(int) ind.n_elem; i++)\n        temp.col(ind(i))=y_star.col(i);\n    }\n\n    com=join_cols(com,temp);\n  }\n}\n\n\nmat sub_mat(mat & com, vec  ID, int id)\n{\n  int p=com.n_cols,i;\n  uvec ind=find(ID==id);\n  int m=(int) ind.n_elem;\n  mat temp(m,p);\n  for(i=0; i<p; i++)\n  {\n    vec a=com.col(i);\n    temp.col(i)=a(ind);\n  }\n\n  return temp;\n\n}\n\n\n//paramter estimates\nvoid est2(mat &com, mat & mu, mat & S, vec & prop, vec &mmu, vec & prob, vec & q)\n{\n  int p=S.n_cols;\n  int G=prop.n_elem;\n  mat e=com.submat(0,1,com.n_rows-1,p);\n  for(int k=0; k<G; k++)\n  {\n   // cout<<\"k\\n\"<<k<<\"\\n\";\n    mat tep=sub_mat(com,com.col(com.n_cols-2),k+1);\n    vec w=tep.col(tep.n_cols-1);\n    for(int j=0; j<p; j++)\n      mu(k,j)=sum(tep.col(j+1)%w)/sum(w);\n    prop(k)=sum(tep.col(tep.n_cols-1))/sum(com.col(com.n_cols-1));\n  }\n\n  for(int i=0; i<(int) e.n_rows; i++)\n  {\n    int g=com(i,com.n_cols-2);\n    e.row(i)=e.row(i)-mu.row(g-1);\n  }\n\n  vec w1=com.col(com.n_cols-1);\n  for(int i=0; i<p; i++)\n    for(int j=0; j<p; j++)\n    {\n      S(i,j)=sum(e.col(i)%e.col(j)%w1)/sum(w1);\n    }\n\n  for(int i=0; i<(int) mmu.n_elem; i++)\n  {\n    mmu(i)=sum(com.col(i+1)%w1)/sum(w1);\n    prob(i)=sum((com.col(i+1)<q(i))%w1)/sum(w1);\n  }\n\n\n}\n\n\n//update weights\nvoid updatew2(mat & com, mat &  mu, mat & S, vec & mu0, mat & S0, vec & prop, int G, int m)\n{\n  //int n=(com.col(0)).max();\n  int p=com.n_cols;\n  //cout<<\"com\\n\"<<com.n_rows<<\"\\n\";\n  int i=0;\n  while(i <(int) com.n_rows)\n  {\n    if(com(i,p-3)==1)\n    {\n      mat Y=com.submat(i,1,i+G-1,p-4);\n\n      vec w(G);\n\n      for(int j=0; j<G; j++)\n      {\n        vec z=(Y.row(j)).t();\n        vec mug= (mu.row(j)).t();\n        w(j)=exp(0.5*as_scalar((z-mu0).t()*S0.i()*(z-mu0)-(z-mug).t()*S.i()*(z-mug))+\n          0.5*log(det(S0))-0.5*log(det(S)))*prop(j);\n      }\n      w=w/sum(w);\n      //cout<<\"w\\n\"<<w<<\"\\n\";\n      com.submat(i,p-1,i+G-1,p-1)=w;\n\n      i=i+G;\n    }\n    else\n    {\n      mat Y=com.submat(i,1,i+m*G-1,p-4);\n      mat CV=cov(Y);\n      uvec ind=find(CV.diag()>1e-8);\n      vec z=(Y.row(0)).t();\n      vec zobs=z(ind);\n      mat S1=S(ind, ind);\n      vec wg(G);\n      vec mu0g=mu0(ind);\n      vec S2=S0(ind, ind);\n      for(int g=0; g<G; g++)\n      {\n        vec mug=(mu.row(g)).t();\n        vec muobs=mug(ind);\n        wg(g)=exp(0.5*as_scalar((zobs-mu0g).t()*S2.i()*(zobs-mu0g)-\n          (zobs-muobs).t()*S1.i()*(zobs-muobs))+\n          0.5*log(det(S2))-0.5*log(det(S1)))*prop(g);\n\n      }\n      wg=wg/sum(wg);\n      vec wf;\n      for(int g=0; g<G; g++)\n      {\n        mat Y1=Y.submat(g*m,0,g*m+m-1,Y.n_cols-1);\n        vec mug=(mu.row(g)).t();\n        vec w(m);\n        for(int j=0; j<m; j++)\n        {\n          z=(Y1.row(j)).t();\n          w(j)=exp(0.5*as_scalar((z-mu0).t()*S0.i()*(z-mu0)-(z-mug).t()*S.i()*(z-mug))+\n            0.5*log(det(S0))-0.5*log(det(S)));\n        }\n        w=w/sum(w)*wg(g);\n        wf=join_cols(wf,w);\n\n      }\n      //cout<<\"w\\n\"<<w<<\"\\n\";\n      com.submat(i,p-1,i+m*G-1,p-1)=wf;\n      i=i+m*G;\n    }\n}\n}\n\n\n\nvec BIC_cpp(mat & s, mat & mu, mat & S, vec & prop, int G )\n{\n  int n=s.n_rows;\n  int p=s.n_cols;\n  int i,k;\n  double l=0.0;\n  //cout<<\"PG\\t\"<<PG<<\"\\n\";\n  for(i=0; i<n; i++)\n  {\n    vec y=(s.row(i)).t();\n    //cout<<i<<\"\\t\"<<y<<\"\\n\";\n    double f=0.0;\n    uvec index=find(y==0);\n    if(index.n_elem==0)\n    {\n      for(k=0; k<G; k++)\n      {\n        vec me=(mu.row(k)).t();\n        mat va=S;\n        f=f+prop(k)*pow(det(2*datum::pi*va),-0.5)*exp(-\n          0.5*as_scalar((y-me).t()*va.i()*(y-me)));\n      }\n\n    }\n    else\n    {\n      for(k=0; k<G; k++)\n      {\n        vec me=(mu.row(k)).t();\n        vec me1=me(find(y!=0));\n        mat va=S;\n        uvec ind=find(y!=0);\n        //cout<<\"ind\\t\"<<ind<<\"\\n\";\n        mat va1(ind.n_elem, ind.n_elem);\n        for(int u=0; u<(int)ind.n_elem; u++)\n          for(int v=0; v<(int)ind.n_elem; v++)\n            va1(u,v)=va(ind(u),ind(v));\n        //cout<<\"va1\\t\"<<va1<<\"\\n\";\n        //cout<<\"va\\t\"<<va<<\"\\n\";\n        //cout<<\"det\\t\"<<det(2*datum::pi*va1)<<\"\\n\";\n        f=f+prop(k)*pow(det(2*datum::pi*va1),-0.5)*exp(-\n          0.5*as_scalar((y(ind)-me1).t()*va1.i()*(y(ind)-me1)));\n      }\n    }\n    l=l+log(f);\n  }\n\n  vec cr(2);\n  cr(0)=-2*l+log(n)*(G-1+G*p+p*(p+1)/2.0);\n  cr(1)=-2*l+2*(G-1+G*p+p*(p+1)/2.0);\n  return cr;\n\n}\n\n//[[Rcpp::export]]\nvec FIGMM(mat s,vec q, int iter, int m, int G)\n{\n  //int n=s.n_rows;\n  int p=s.n_cols;\n  int i;\n  mat obs, mis;\n  find_obs( s, obs,mis);\n  vec mu0;\n  mat S0;\n  proposal_est( obs, mu0,S0);\n  cout<<\"mu0\\t\"<<mu0<<\"\\n\";\n  mat com;\n  ImputationGMM( s,  mu0,S0, G, m,  com);\n  cout<<\"com\\n\"<<com.head_rows(5)<<\"\\n\";\n  mat mu=repmat(mu0.t(),G,1);\n  vec prop=1.0/G*ones(G);\n  vec prob=zeros(p),mmu=mu0;\n  mat S=S0;\n  vec p1=mu0;\n  //cout<<\"out\\t\"<<S<<mu<<prob<<prop<<mmu<<\"\\n\";\n\n  for(i=0; i<iter; i++)\n  {\n    est2(com, mu,  S,  prop, mmu,  prob, q);\n    cout<<\"i\\n\"<<i<<\"\\n\";\n    cout<<\"mu\\n\"<<mu<<\"\\n\";\n    cout<<\"prop\\n\"<<prop<<\"\\n\";\n    updatew2( com,  mu, S, mu0,S0,prop,G, m);\n    if(norm(mmu-p1)/norm(mmu)<1e-6 && i>100) break;\n    p1=mmu;\n  }\n\n  vec bic=BIC_cpp( s,  mu, S,  prop, G );\n\n  vec r=join_cols(mmu, prob);\n\n  r=join_cols(r,vectorise(S));\n  r=join_cols(r,bic);\n  return r;\n}\n\n\n\n\n//Imputatin for model and Missing data\nvoid update_ImputationGMM(mat & s, mat & mu, mat & S, int G, int m, mat & com)\n{\n  int n=s.n_rows;\n  //int p=s.n_cols;\n  mat s1=join_rows(linspace(1,n,n),s);\n  //cout<<\"s1\\n\"<<s1.head_rows(5)<<\"\\n\";\n  vec z;\n  uvec ind;\n  mat temp, com1;\n  for(int i=0; i<n; i++)\n  {\n    z=(s1.row(i)).t();\n    //cout<<\"z\\n\"<<z<<\"\\n\";\n    ind=find(z==0);\n    if(ind.n_elem==0)\n    {\n      temp=repmat(z.t(),G,1);\n      temp=join_rows(temp,ones(G));\n      temp=join_rows(temp,linspace(1,G,G));\n      temp=join_rows(temp,1.0/G*ones(G));\n      com1=join_cols(com1,temp);\n    }\n    else\n    {\n      for(int g=1; g<G+1; g++)\n      {\n        temp=repmat(z.t(),m,1);\n        // cout<<\"temp\\n\"<<temp<<\"\\n\";\n        temp=join_rows(temp,zeros(m));\n        // cout<<\"temp\\n\"<<temp<<\"\\n\";\n        temp=join_rows(temp,g*ones(m));\n        //cout<<\"temp\\n\"<<temp<<\"\\n\";\n        temp=join_rows(temp,1.0/(G*m)*ones(m));\n\n        //cout<<\"temp\\n\"<<temp<<\"\\n\";\n        // Imputation\n        // imputation\n        vec z1=z.subvec(1,z.n_elem-1);\n        vec mu0=(mu.row(g-1)).t();\n        vec mu1=mu0(find(z1==0));\n        vec mu2=mu0(find(z1!=0));\n        int r1=mu1.n_elem;\n        int r2=mu2.n_elem;\n        uvec ind1=find(z1==0);\n        uvec ind2=find(z1!=0);\n        mat S1(r1,r1), S2(r2,r2), S3(r1,r2);\n        for(int i=0; i<r1; i++)\n          for(int j=0; j<r1; j++)\n            S1(i,j)=S(ind1(i),ind1(j));\n\n        for(int i=0; i<r2; i++)\n          for(int j=0; j<r2; j++)\n            S2(i,j)=S(ind2(i),ind2(j));\n\n        for(int i=0; i<r1; i++)\n          for(int j=0; j<r2; j++)\n            S3(i,j)=S(ind1(i),ind2(j));\n        vec b=z1(find(z1!=0));\n        vec mu_star=mu1+S3*S2.i()*(b-mu2);\n        mat S_star=S1-S3*S2.i()*S3.t();\n\n        mat y_star=mvrnormArma(m,mu_star,S_star);\n        //cout<<\"y_star\\n\"<<y_star<<\"\\n\";\n        for(int i=0; i<(int) ind.n_elem; i++)\n          temp.col(ind(i))=y_star.col(i);\n        com1=join_cols(com1,temp);\n\n      }\n\n\n\n    }\n\n  }\n  com=com1;\n}\n\n\n\n//update weights\nvoid updatew3(mat & com, mat &  mu, mat & S, vec & prop, int G, int m)\n{\n  //int n=(com.col(0)).max();\n  int p=com.n_cols;\n  //cout<<\"com\\n\"<<com.n_rows<<\"\\n\";\n  int i=0;\n  while(i <(int) com.n_rows)\n  {\n    if(com(i,p-3)==1)\n    {\n      mat Y=com.submat(i,1,i+G-1,p-4);\n\n      vec w(G);\n\n      for(int j=0; j<G; j++)\n      {\n        vec z=(Y.row(j)).t();\n        vec mug= (mu.row(j)).t();\n        w(j)=exp(-0.5*as_scalar((z-mug).t()*S.i()*(z-mug))-0.5*log(det(S)))*prop(j);\n      }\n      w=w/sum(w);\n      //cout<<\"w\\n\"<<w<<\"\\n\";\n      com.submat(i,p-1,i+G-1,p-1)=w;\n\n      i=i+G;\n    }\n    else\n    {\n      mat Y=com.submat(i,1,i+m*G-1,p-4);\n      mat CV=cov(Y);\n      uvec ind=find(CV.diag()>1e-8);\n      vec z=(Y.row(0)).t();\n      vec zobs=z(ind);\n      mat S1=S(ind, ind);\n      vec wg(G);\n      for(int g=0; g<G; g++)\n      {\n        vec mug=(mu.row(g)).t();\n        vec muobs=mug(ind);\n        wg(g)=exp(0.5*as_scalar(-\n          (zobs-muobs).t()*S1.i()*(zobs-muobs))-0.5*log(det(S1)))*prop(g);\n\n      }\n      wg=wg/sum(wg);\n      vec wf;\n      for(int g=0; g<G; g++)\n      {\n        vec w(m);\n        for(int j=0; j<m; j++)\n        {\n          w(j)=1.0/m;\n        }\n        w=w/sum(w)*wg(g);\n        wf=join_cols(wf,w);\n\n      }\n      //cout<<\"w\\n\"<<w<<\"\\n\";\n      com.submat(i,p-1,i+m*G-1,p-1)=wf;\n      i=i+m*G;\n    }\n  }\n}\n\n\n\n\n//[[Rcpp::export]]\nvec FIGMM2(mat s,vec q, int iter, int m, int G)\n{\n  //int n=s.n_rows;\n  int p=s.n_cols;\n  int i;\n  mat obs, mis;\n  find_obs( s, obs,mis);\n  vec mu0;\n  mat S0;\n  proposal_est( obs, mu0,S0);\n  cout<<\"mu0\\t\"<<mu0<<\"\\n\";\n  mat com;\n  ImputationGMM( s,  mu0,S0, G, m,  com);\n  //cout<<\"com\\n\"<<com.head_rows(5)<<\"\\n\";\n  mat mu=repmat(mu0.t(),G,1);\n  vec prop=1.0/G*ones(G);\n  vec prob=zeros(p),mmu=mu0;\n  mat S=S0;\n  vec p1=prop;\n  //cout<<\"out\\t\"<<S<<mu<<prob<<prop<<mmu<<\"\\n\";\n\n  for(i=0; i<iter; i++)\n  {\n    updatew3(com, mu,S,prop,G, m);\n    est2(com, mu,  S,  prop, mmu,  prob, q);\n    cout<<\"i\\n\"<<i<<\"\\n\";\n    cout<<\"mu\\n\"<<mu<<\"\\n\";\n    cout<<\"prop\\n\"<<prop<<\"\\n\";\n    update_ImputationGMM(s,mu,S,G,m, com);\n    if(norm(prop-p1)/norm(prop)<1e-6 &&i>100) break;\n    p1=prop;\n  }\n\n  vec bic=BIC_cpp( s,  mu, S,  prop, G );\n\n  vec r=join_cols(mmu, prob);\n  r=join_cols(r,vectorise(S));\n  r=join_cols(r,bic);\n  return r;\n}\n\n\n\n\n\n\n",
    "created" : 1504808143664.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3506385458",
    "id" : "1EC5D7CF",
    "lastKnownWriteTime" : 1504808146,
    "last_content_update" : 1504808146917,
    "path" : "C:/Users/hjsang/Dropbox/KIM/FIGM/FIGM/src/FI_cpp.cpp",
    "project_path" : "src/FI_cpp.cpp",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "cpp"
}